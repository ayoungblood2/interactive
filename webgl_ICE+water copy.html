<!DOCTYPE html>
<html lang="en">

<head>
	<title>ice-time</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r67/three.min.js"></script>
	<script src="https://threejs.org/build/three.min.js"></script>

</head>

<body>

	<div class="ab">
		<div id="about">
			*
		</div>
		<div id="abou">
			<div id = "bottom-text">
				In the winter the days seem longer and the ice melts slower. 
						<!-- The winter solstice (~ December 21st) being the shortest day of the year. -->
							In the summer, the days shorter, the ice melts quickly, and summer ends. 
								<!-- The summer solstice (~ June 21st) being the longest day of the year. 
									That means between December 21st and June 21st, the days get longer, 
										they peak on the first day of summer, and then they get progressively shorter
										 until the first day of winter again.  -->
										<p>It's all sort of surreal in my mind. Like a dream.
											Time freezes, then evaporates. 
												Yet, at the same time, it is a constant. Always bobbing at 
													a steady pace.</p>
												</div>		</div>
	</div>
	

	<div id="container"></div>
		<div id="info">

<h1>Time is like ice.
</h1>

		</div>



	<script type="module">

		import * as THREE from '../build/three.module.js';

		import { GUI } from './jsm/libs/dat.gui.module.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js';

		import { Water } from './jsm/objects/Water2.js';
		import { Sky } from './jsm/objects/Sky.js';

		import { DDSLoader } from './jsm/loaders/DDSLoader.js';
		import { MTLLoader } from './jsm/loaders/MTLLoader.js';
		import { OBJLoader } from './jsm/loaders/OBJLoader.js';
		import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';




		var scene, camera, clock, renderer, light;

		var mesh;

		var controls, water, model, sky;

		var cloudy = false;

		var currentColor = 0xFFFFFF; // color of model

		var torusKnot;

		var parameters = {
			distance: 400,
			inclination: 0.471,
			azimuth: 0.2471,
			turbidity: 1,
			rayleigh: 30,
			luminance: 10,
			mieCoefficient: 5,
			mieDirectionalG: 8
		};

		var params = {
			color: '#ffffff',
			scale: 40,
			flowX: 1,
			flowY: 1,
			flowSpeed: .05
		};


		// SCENE

		scene = new THREE.Scene();

		// CAMERA

		var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		camera.position.z = 100;

		// CLOCK

		clock = new THREE.Clock();


		// LIGHT

		light = new THREE.DirectionalLight(0xffffff, 0.8);

		var keyLight = new THREE.DirectionalLight(new THREE.Color('hsl(30, 100%, 75%)'), 1.0);
		keyLight.position.set(-100, 0, 100);

		var fillLight = new THREE.DirectionalLight(new THREE.Color('hsl(240, 100%, 75%)'), 0.75);
		fillLight.position.set(100, 0, 100);

		var backLight = new THREE.DirectionalLight(0xffffff, 1.0);
		backLight.position.set(100, 0, -100).normalize();

		scene.add(light);
		scene.add(keyLight);
		scene.add(fillLight);
		scene.add(backLight);


		// TORUS KNOT MESH

		var torusKnotGeometry = new THREE.TorusKnotBufferGeometry(300, 10, 256, 32);
		var torusKnotMaterial = new THREE.MeshNormalMaterial();

		torusKnot = new THREE.Mesh(torusKnotGeometry, torusKnotMaterial);
		torusKnot.position.y = 4;
		torusKnot.scale.set(0.5, 0.5, 0.5);
		// scene.add(torusKnot);


		// WATER2 ~ CLEAR FLOW

		var waterGeometry = new THREE.PlaneBufferGeometry(10000, 10000);

		water = new Water(waterGeometry, {
			color: params.color,
			scale: params.scale,
			flowDirection: new THREE.Vector2(params.flowX, params.flowY),
			flowSpeed: params.flowSpeed,
			textureWidth: 1024,
			textureHeight: 1024,
			sunDirection: light.position.clone().normalize(),
			sunColor: 'ff0000',
			distortionScale: 3.7,
			fog: scene.fog !== undefined
		});

		water.position.y = -18.5;
		water.rotation.x = Math.PI * - 0.5;
		scene.add(water);


		// WATER ~ OCEAN SILVER

		// var waterGeometry = new THREE.PlaneBufferGeometry(10000, 10000);

		// water = new Water(waterGeometry, {
		// 		textureWidth: 512,
		// 		textureHeight: 512,
		// 		waterNormals: new THREE.TextureLoader().load('textures/waternormals.jpg', function (texture) {

		// 			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

		// 		}),
		// 		sunDirection: light.position.clone().normalize(),
		// 		sunColor: 0xffffff,
		// 		distortionScale: 3.7,
		// 		fog: scene.fog !== undefined
		// 	});

		// water.position.y = -18.5;
		// water.rotation.x = - Math.PI / 2;
		// scene.add(water);


		// SKYBOX SUN 

		sky = new Sky();
		sky.scale.setScalar(450000);
		scene.add(sky);

		var uniforms = sky.material.uniforms;

		// uniforms['turbidity'].value = 10;
		// uniforms['rayleigh'].value = 2;
		// uniforms['luminance'].value = 1;
		// uniforms['mieCoefficient'].value = 0.005;
		// uniforms['mieDirectionalG'].value = 0.8;

		uniforms['turbidity'].value = parameters.turbidity;
		uniforms['rayleigh'].value = parameters.rayleigh;
		uniforms['luminance'].value = parameters.luminance;
		uniforms['mieCoefficient'].value = parameters.mieCoefficient;
		uniforms['mieDirectionalG'].value = parameters.mieDirectionalG;


		var cubeCamera = new THREE.CubeCamera(0.1, 1, 512);
		cubeCamera.renderTarget.texture.generateMipmaps = true;
		cubeCamera.renderTarget.texture.minFilter = THREE.LinearMipmapLinearFilter;

		scene.background = cubeCamera.renderTarget;

		function updateSun() {

			var theta = Math.PI * (parameters.inclination - 0.5);
			var phi = 2 * Math.PI * (parameters.azimuth - 0.5);

			light.position.x = parameters.distance * Math.cos(phi);
			light.position.y = parameters.distance * Math.sin(phi) * Math.sin(theta);
			light.position.z = parameters.distance * Math.sin(phi) * Math.cos(theta);


			sky.material.uniforms['sunPosition'].value = light.position.copy(light.position);
			// water.material.uniforms['sunDirection'].value.copy(light.position).normalize();

		}

		updateSun();


		// MODEL MATERIAL

		// material samples

		var cubeMaterial3 = new THREE.MeshPhongMaterial({ color: 0xccddff, envMap: sky, refractionRatio: 0.98, reflectivity: 0.9 });
		var cubeMaterial2 = new THREE.MeshPhongMaterial({ color: 0xccfffd, envMap: sky, refractionRatio: 0.985 });
		var cubeMaterial1 = new THREE.MeshPhongMaterial({ color: 0xffffff, envMap: sky, refractionRatio: 0.98 });

		// ICE MODEL

		// onProgress callback
		var onProgress = function (xhr) {
			if (xhr.lengthComputable) {
				var percentComplete = xhr.loaded / xhr.total * 100;
				console.log(Math.round(percentComplete, 2) + '% downloaded');
			}
		};
		// onError callback
		var onError = function () { };
		// loading
		var manager = new THREE.LoadingManager();
		manager.addHandler(/\.dds$/i, new DDSLoader());
		// model scale
		var objectScale = .08;
		// load model and material
		var material = new MTLLoader(manager)
			.setPath('models/obj/ice/')
			.load('iceCube_v2_edit_2.mtl', function (materials) {

				materials.preload();

		var object = new OBJLoader(manager)
			.setMaterials(materials)
			.setPath('models/obj/ice/')
			.load('iceCube_v2_edit_2.obj', function (object) {



				object.position.x = - 4;
				// object.position.z = 40;
				object.scale.set(objectScale, objectScale, objectScale);
				model = object;
				scene.add(model);

			}, onProgress, onError);
		});






		// RENDERER

		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setClearColor(0xccccff);
		document.body.appendChild(renderer.domElement);


		// ORBIT CONTROLS

		var controls = new OrbitControls(camera, renderer.domElement);
		controls.enableDamping = true;
		controls.dampingFactor = 0.25;
		controls.enableZoom = true;
		controls.enablePan = true;
		controls.keyPanSpeed = 20;
		controls.maxPolarAngle = Math.PI * 0.495;
		controls.target.set(0, 10, 0);
		controls.minDistance = 40.0;
		controls.maxDistance = 500.0;
		controls.update();


		// GUI

		var gui = new GUI();

		var uniforms = sky.material.uniforms;
		var folder = gui.addFolder('Sky');
		folder.add(parameters, 'inclination', 0, 0.5, 0.0001).onChange(updateSun);
		folder.add(parameters, 'azimuth', 0, 1, 0.0001).onChange(updateSun);
		folder.open();

		var uniforms = water.material.uniforms;

		var folder = gui.addFolder('Water');
		folder.addColor(params, 'color').onChange(function (value) {
			water.material.uniforms['color'].value.set(value);
		});
		folder.add(params, 'scale', 1, 50).onChange(function (value) {
			water.material.uniforms['config'].value.w = value;
		});
		folder.add(params, 'flowX', - 10, 10).step(0.01).onChange(function (value) {
			water.material.uniforms['flowDirection'].value.x = value;
			water.material.uniforms['flowDirection'].value.normalize();
		});
		folder.add(params, 'flowY', - 10, 10).step(0.01).onChange(function (value) {
			water.material.uniforms['flowDirection'].value.y = value;
			water.material.uniforms['flowDirection'].value.normalize();
		});

		// folder.add(uniforms.distortionScale, 'value', 0, 8, 0.1).name('distortionScale');
		// folder.add(uniforms.size, 'value', 0.1, 10, 0.1).name('size');
		folder.open();


		// WINDOW RESIZE

		window.addEventListener('resize', onResize, false);

		function onResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);

		}


		// ANIMATE & RENDER

		function animate() {

			requestAnimationFrame(animate);
			render();

		}

		function render() {

			var delta = clock.getDelta();

			var time = performance.now() * 0.001;

			// model.position.y = Math.sin(time) * 5 - 5;
			model.position.y = Math.sin(time) * 50 - 45;
			// model.rotation.x = time * 0.5;
			// model.rotation.z = time * 0.51;

			// water.material.uniforms['time'].value += 1.0 / 60.0;

			torusKnot.rotation.x += delta;
			torusKnot.rotation.y += delta * 0.5;

			sky.material.uniforms.value += Math.sin(time) * 5 - 5;

			cubeCamera.update(renderer, sky);

			renderer.render(scene, camera);

		}

		animate();

	</script>

</body>

</html>